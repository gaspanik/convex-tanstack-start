# Convex + TanStack Start Project

## Architecture Overview

This is a full-stack TypeScript application combining:
- **Backend**: Convex (real-time database with serverless functions in `convex/`)
- **Frontend**: TanStack Router + TanStack Query + React 19 + Vite
- **Styling**: Tailwind CSS v4 (using new Vite plugin)

Key architectural decision: Uses `@convex-dev/react-query` to bridge Convex backend with TanStack Query, enabling unified data fetching patterns across the app.

## Development Workflow

```bash
# Start development (runs Convex + Vite concurrently)
npm run dev

# IMPORTANT: First run initializes Convex with `--once` flag
# Subsequent dev sessions run both servers via concurrently

# Type checking only (no emit)
npm run lint

# Format all files
npm run format
```

**Environment requirement**: Must have `VITE_CONVEX_URL` in `.env.local` (auto-generated by Convex CLI).

## Convex Function Patterns

### Always use NEW function syntax (not old builder pattern):
```typescript
import { query, mutation, action } from './_generated/server'
import { v } from 'convex/values'

// Query (read-only, reactive)
export const myQuery = query({
  args: { count: v.number() },
  handler: async (ctx, args) => {
    return await ctx.db.query('tableName').take(args.count)
  },
})

// Mutation (writes to DB, transactional)
export const myMutation = mutation({
  args: { value: v.string() },
  handler: async (ctx, args) => {
    return await ctx.db.insert('tableName', { value: args.value })
  },
})

// Action (can call external APIs, non-transactional)
export const myAction = action({
  args: { input: v.number() },
  handler: async (ctx, args) => {
    await ctx.runMutation(api.myFunctions.myMutation, { value: 'data' })
  },
})
```

### Validators reference:
- `v.id(tableName)` for document IDs
- `v.null()` for null returns (use `returns: v.null()`)
- `v.array(v.string())` for arrays
- `v.union()` for discriminated unions
- `v.object({})` for exact shapes, `v.record(v.string(), v.any())` for dynamic keys

## Frontend Integration Pattern

**Router setup** (`src/router.tsx`):
- `ConvexQueryClient` wraps Convex backend
- Connected to TanStack Query via `queryKeyHashFn()` and `queryFn()`
- Must call `convexQueryClient.connect(queryClient)` before creating router
- Wrapped in `<ConvexProvider>` for `useMutation` hook

**Using Convex in components**:
```typescript
import { useSuspenseQuery } from '@tanstack/react-query'
import { convexQuery } from '@convex-dev/react-query'
import { useMutation } from 'convex/react'
import { api } from '../../convex/_generated/api'

// Queries via TanStack Query
const { data } = useSuspenseQuery(
  convexQuery(api.myFunctions.listNumbers, { count: 10 })
)

// Mutations via Convex React
const addNumber = useMutation(api.myFunctions.addNumber)
addNumber({ value: 42 }) // Fire and forget
```

## Project Conventions

- **Imports**: Use `~/*` alias for `src/*` (configured in tsconfig paths)
- **Styling**: Tailwind v4 with CSS file in `src/styles/app.css` (imported via `?url` in `__root.tsx`)
- **Route files**: File-based routing in `src/routes/`, `routeTree.gen.ts` is auto-generated
- **Convex schema**: Optional but recommended in `convex/schema.ts` for TypeScript types
- **Generated files**: Never edit `convex/_generated/*` - regenerated by Convex CLI

## Database Patterns

- Use `.order('desc')` for descending, `.take(n)` for limits, `.collect()` for all results
- Schema is optional but provides better TypeScript inference
- Auth available via `ctx.auth.getUserIdentity()` in functions (see `listNumbers` example)

## Linting & Type Safety

- ESLint uses both `@tanstack/eslint-config` and `@convex-dev/eslint-plugin`
- Ignore `convex/_generated` in all tooling
- Strict TypeScript with `noUnusedLocals`, `noUnusedParameters` enabled
- No emit mode (`noEmit: true`) - Vite handles bundling
